package com.sjsu.flink; // Use your package name

import org.apache.flink.table.functions.ScalarFunction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;

/**
 * A Flink ScalarFunction to calculate the estimated Jaccard Similarity
 * between two MinHash signatures (represented as List<Long>).
 */
public class CalculateSimilarity extends ScalarFunction {
    private static final Logger LOG = LoggerFactory.getLogger(CalculateSimilarity.class);

    // The main evaluation method called by Flink SQL
    public Double eval(List<Long> signature1, List<Long> signature2) {

        // --- Input Validation ---
        if (signature1 == null || signature2 == null || signature1.isEmpty() || signature2.isEmpty()) {
            LOG.debug("One or both signatures are null or empty. Returning 0.0 similarity.");
            return 0.0; // Or null if you prefer to indicate invalid comparison
        }

        if (signature1.size() != signature2.size()) {
            // This shouldn't happen if generated by the same LSHAggregateFunction instance,
            // but defensive check is good.
            LOG.warn("Signatures have different lengths ({} vs {}). Cannot compare accurately. Returning 0.0.",
                     signature1.size(), signature2.size());
            return 0.0; // Cannot compute similarity reliably
        }

        int numHashFunctions = signature1.size(); // Length of the signatures
        if (numHashFunctions == 0) {
            LOG.debug("Signatures have zero length. Returning 0.0 similarity.");
            return 0.0; // Avoid division by zero
        }

        // --- Similarity Calculation ---
        int matchingHashes = 0;
        for (int i = 0; i < numHashFunctions; i++) {
            // Retrieve hash values at the same index
            Long hash1 = signature1.get(i);
            Long hash2 = signature2.get(i);

            // Check for equality (handle potential nulls within the list, though unlikely)
            if (hash1 != null && hash1.equals(hash2)) {
                matchingHashes++;
            }
        }

        // Estimated Jaccard Similarity = (Number of matching hashes) / (Total number of hashes)
        double similarity = (double) matchingHashes / numHashFunctions;

        LOG.trace("Calculated similarity: {} ({} matching out of {})", similarity, matchingHashes, numHashFunctions);
        return similarity;
    }
}